#include <cstdint>
#include <iostream>
#include <inttypes.h>

// Somewhat arbitrary choice of blocks and threads
const int BLOCKS = 1024;
const int THREADS = 256;

// Number of weights to divide
const size_t LENGTH = 28;
// 2**28 "possible" first groups
const uint32_t POSSIBLES = 1 << LENGTH;

const size_t ONE = 1;

// Set of weights to manage
__constant__ uint32_t WEIGHTS[LENGTH] = {
    1, 3, 5, 11, 13, 17, 19, 23, 29, 31, 37, 
    41, 43, 47, 53, 59, 67, 71, 73, 79, 83, 
    89, 97, 101, 103, 107, 109, 113};

// Total sum of WEIGHTS
const uint32_t TOTAL_WEIGHT = 1524;
// 1/3 of TOTAL_WEIGHT (Part 1)
const uint32_t GROUP_WEIGHT1 = TOTAL_WEIGHT / 3;
// 1/4 of TOTAL_WEIGHT (Part 2)
const uint32_t GROUP_WEIGHT2 = TOTAL_WEIGHT / 4;

// Heap of integers representing sets of weights for first group
__device__ __managed__ uint32_t* heap;
// Size of heap
__device__ __managed__ size_t heapSize = 0;
// Heap of integers represeting sets of weights for other groups (Part 2 only)
__device__ __managed__ uint32_t* otherHeap;
// Size of otherHeap
__device__ __managed__ size_t otherHeapSize = 0;
// Current index of heap
__device__ __managed__ size_t heapIdx = 0;

// Smallest cardinality found for first group
__device__ __managed__ uint32_t bestCardinality = UINT_MAX;
// Smallest product found in smallest cardinality for first group
__device__ __managed__ uint64_t bestQE = UINT64_MAX;

// Convert an integer N into a set of weights (returns number of nonzero weights)
__device__ size_t convert_weights(uint32_t N, uint32_t weights[LENGTH])
{
    size_t cardinality = 0;
    for(size_t i = 0; i < LENGTH; ++i)
    {
        weights[i] = 0;
        if (N % 2 == 1)
        {
            weights[i] = WEIGHTS[i];
            ++cardinality;
        }
        N /= 2;
    }
    return cardinality;
}

// Calculate sum of weights 
__device__ uint32_t sum(uint32_t weights[LENGTH])
{
    uint32_t total = 0;
    for(size_t i = 0; i < LENGTH; ++i)
    {
        total += weights[i];
    }
    return total;
}

// Calculate product of weights (qe -> quantum entanglement)
__device__ uint64_t product(uint32_t weights[LENGTH])
{
    uint64_t qe = 1;
    for(size_t i = 0; i < LENGTH; ++i)
    {
        if (weights[i] > 0)
        {
            qe *= static_cast<uint64_t>(weights[i]);
        }
    }
    return qe;
}

// Compare the weights generated by two integers to see which is better, 
//   according to the sum and product rules given
__device__ bool compare_weights(int64_t N1, int64_t N2)
{
    // If equal or N1 is large
    if (N1 == N2 || N1 == UINT_MAX)
    {
        return false;
    }
    // N2 is large
    if (N2 == UINT_MAX)
    {
        return true;
    }

    // Set weights for N1
    uint32_t weights1[LENGTH];
    convert_weights(N1, weights1);

    // Set weights for N2
    uint32_t weights2[LENGTH]; 
    convert_weights(N2, weights2);

    // Compare weights' sums
    uint32_t sumWeights1 = sum(weights1);
    uint32_t sumWeights2 = sum(weights2);
    if (sumWeights1 != sumWeights2)
    {
        return sumWeights1 < sumWeights2;
    }

    // Compare weights' products
    uint64_t qe1 = product(weights1);
    uint64_t qe2 = product(weights2);
    return qe1 < qe2;
}

// One step for bitonic sort
__global__ void bitonic_sort_step(uint64_t j, uint64_t k)
{
    uint64_t i = threadIdx.x + blockDim.x * blockIdx.x;
    uint64_t ij = i ^ j;
    if (ij > i)
    {
        uint64_t ik = i&k;
        if ( (ik == 0 && compare_weights(heap[ij], heap[i])) ||
             (ik != 0 && compare_weights(heap[i], heap[ij])) )
        {
            uint64_t temp = heap[i];
            heap[i] = heap[ij];
            heap[ij] = temp;
        }
    }
}

// Complete bitonic sort (Part 1, step 4 and Part 2, step 4)
__host__ void bitonic_sort(size_t nextPow2)
{
    for (uint64_t x = heapSize; x < nextPow2; ++x)
    {
        heap[x] = UINT_MAX;
    }
    uint64_t threads = THREADS;
    uint64_t blocks = nextPow2 / threads;

    for (uint64_t k = 2; k <= nextPow2; k <<= 1)
    {
        for(uint64_t j = k >> 1; j > 0; j = j >> 1)
        {
            bitonic_sort_step<<<blocks,threads>>>(j, k);
        }
    }
}

/** 
 * Step 1 for Parts 1 and 2:
 *   Find the number of possible smallest groups (by looping over all non-negative 
 *   integers < 2**28). Those groups that sum to 1/3 of the total weight and fewer 
 *   than 10 elements. (Steps 1 for Parts 1 and 2)
 * 
 * Step 3 for Parts 1 and 2:
 *   Similar to Step 1, but add the integer to the heap insteading of incrementing
 *   the heap size.
 */
__global__ void find_first_groups(const size_t worstCardinality, 
                                 const uint32_t groupWeight, 
                                 const bool addToHeap)
{
    uint32_t weights[LENGTH];
    size_t cardinality = 0;
    uint32_t sumWeights = 0;
    for(uint32_t N = threadIdx.x + blockDim.x * blockIdx.x; 
        N < POSSIBLES; 
        N += blockDim.x * gridDim.x)
    {   
        // Convert integer to weights group
        cardinality = convert_weights(N, weights);
        // If cardinality > 9, it's not the smallest group in arrangement
        if (cardinality > worstCardinality)
        {
            continue;
        }

        // Weights must sum to 1/3 TOTAL WEIGHT
        sumWeights = sum(weights);
        if (sumWeights != groupWeight)
        {
            continue;
        }

        if (addToHeap)
        {
            // Add this integer to the heap
            size_t idx = atomicAdd(&heapIdx, ONE);
            heap[idx] = N;            
        }
        else
        {
            // Increment heap size to make room for this N in next pass
            atomicAdd(&heapSize, ONE);
        }
    }
}

/**
 * Step 2 for Parts 1 and 2, Step 5 for Part 2
 *   Allocate memory for the heap to hold the integers found in previous steps
 */
__host__ void allocate_heap(size_t heapNumber)
{
    if (heapNumber == 1)
    {
        // Allocate to next power of 2 (helps with bitonic_sort)
        size_t nextPow2 = pow(2, ceil(log(heapSize)/log(2)));
        cudaMallocManaged(&heap, nextPow2 * sizeof(uint32_t));
    }
    if (heapNumber == 2)
    {
        // Allocate to next power of 2 (helps with bitonic_sort)
        size_t nextPow2 = pow(2, ceil(log(otherHeapSize)/log(2)));
        cudaMallocManaged(&otherHeap, nextPow2 * sizeof(uint32_t));
    }
}

/**
 * Step 4 for Parts 1 and 2: 
 *   Sort the heap using bitonic_sort, first by cardinality of the 
 *   corresponding group, then by the product of the elements of 
 *   the group.
 */
__host__ void sort_heap()
{
    // Bitonic_sort works on powers of 2
    size_t nextPow2 = pow(2, ceil(log(heapSize)/log(2)));
    bitonic_sort(nextPow2);
}

/**
 * Step 5 for Part 1:
 *   For each non-negative integers < 2**28, get a group of weights ("second group"). 
 *   If this second group sums to 1/3 the weight, test it against every "first group" 
 *   from the heap. If they don't overlap in any weights, this also gives a "third group"
 *   to give a valid arrangement. If so, test the cardinality and product of the "first group" 
 *   against the best arrangement found so far.
 */
__global__ void test_valid_arrangements()
{
    // Weight arrays
    uint32_t weights1[LENGTH];
    uint32_t weights2[LENGTH];

    // Cardinalities
    uint32_t cardinality1 = 0;
    uint32_t cardinality2 = 0;
    uint32_t cardinality3 = 0;

    // Sum of weights
    uint32_t sumWeights2 = 0;

    // Product of weights (quantum entanglement)
    uint64_t qe1 = 0;

    // Allocate some temp integers
    uint32_t N1 = 0;

    // Loop over integers < 2**28 (second group)
    for(int64_t N2 = threadIdx.x + blockDim.x * blockIdx.x; 
        N2 < POSSIBLES; 
        N2 += blockDim.x * gridDim.x)
    {   
        // Get second group weights
        cardinality2 = convert_weights(N2, weights2);

        // Calculate sum of weights
        sumWeights2 = sum(weights2);

        // Check for invalid group
        if (sumWeights2 != GROUP_WEIGHT1)
        {
            continue;
        }

        // Loop over all first group weights in heap
        for (uint64_t idx = 0; idx < heapSize; ++idx)
        {
            N1 = heap[idx];
            // If N1 & N2 is not zero, weights overlap
            if ((N1 & N2) != 0)
            {
                continue;
            }

            // Get first group weights
            cardinality1 = convert_weights(N1, weights1);

            // Check if already bigger than bestCardinality or smaller than second group
            if (cardinality1 > bestCardinality || cardinality2 < cardinality1)
            {
                break;
            }

            // Cardinality of third group
            cardinality3 = LENGTH - (cardinality1 + cardinality2);

            // Check if it's smaller than first group
            if (cardinality3 < cardinality1)
            {
                continue;
            }

            // Test against the best arrangement so far
            qe1 = product(weights1);
            if (cardinality1 == bestCardinality && qe1 >= bestQE)
            {
                break;
            }
            else
            {
                atomicMin(&bestCardinality, cardinality1);
                atomicMin(&bestQE, qe1);
                break;
            }
        }
    }
}

/**
 * Step 5 for Part 2:
 *   Find the number of possible other groups (by looping over all non-negative 
 *   integers < 2**28): those groups that sum to 1/4 of the total weight and 
 *   have at least one non-overlapping group in the first heap whose cardinality 
 *   is not bigger than its cardinality.
 *
 * Step 7 for Part 2:
 *   Similar to Step 4, but add integer to otherHeap instead of just incrementing 
 *   the heap size
 */
__global__ void find_other_groups(bool addToHeap)
{
    // Weight arrays
    uint32_t weights1[LENGTH];
    uint32_t weights2[LENGTH];

    // Cardinalities
    uint32_t cardinality1 = 0;
    uint32_t cardinality2 = 0;

    // Sum of weights
    uint32_t sumWeights2 = 0;

    // Allocate some temp integers
    uint32_t N1 = 0;

    // Loop over integers < 2**28 for second group
    for(uint32_t N2 = threadIdx.x + blockDim.x * blockIdx.x; 
                 N2 < POSSIBLES; 
                 N2 += blockDim.x * gridDim.x)
    {   
        cardinality2 = convert_weights(N2, weights2);
        sumWeights2 = sum(weights2);
        // Check if valid group
        if (sumWeights2 != GROUP_WEIGHT2)
        {
            continue;
        }
        // Check if there's at least one valid first group that goes with this second group
        bool validN2 = false;
        // Loop over all first group weights in heap
        for (uint64_t idx = 0; idx < heapSize; ++idx)
        {
            N1 = heap[idx];
            // If N1 & N2 is not zero, weights overlap
            if ((N1 & N2) != 0)
            {
                continue;
            }

            // Second group can't be smaller than first group
            cardinality1 = convert_weights(N1, weights1);
            if (cardinality2 < cardinality1)
            {
                continue;
            }
            // Found a possible first group, so break
            validN2 = true;
            break;
        }
        // Possible valid N2
        if (validN2)
        {
            if(addToHeap)
            {
               // Add integer to otherHeap
               size_t idx = atomicAdd(&heapIdx, ONE);
               otherHeap[idx] = N2;
            }
            else
            {
                // Increment otherHeap size to make room for this N2 in next pass
                atomicAdd(&otherHeapSize, ONE);
            }
        }
    }
}

/**
 * Step 8 for Part 2:
 *   For every possible pair of groups in the second heap ("second" and "third" groups), 
 *   find the non-overlapping groups in the first heap ("first" groups). If none of the 3 
 *   groups overlap, this also gives a "fourth" group of the remaining unused weights to 
 *   specify a valid arrangement. If so, test the cardinality and product of the "first" 
 *   group against the best arrangement found so far. 
 */
__global__ void test_valid_arrangements2()
{
    // Weight arrays
    uint32_t weights1[LENGTH];
    uint32_t weights2[LENGTH];
    uint32_t weights3[LENGTH];

    // Cardinalities
    uint32_t cardinality1 = 0;
    uint32_t cardinality2 = 0;
    uint32_t cardinality3 = 0;
    uint32_t cardinality4 = 0;
    // cardinality2 + cardinality3
    uint32_t card23 = 0;

    // Product (quantum entanglement)
    uint64_t qe1 = 0;

    // Allocate some integers
    uint32_t N1 = 0;
    uint32_t N2 = 0;
    uint32_t N3 = 0;

    // Loop over otherHeap (third group)
    // Each block handles a different third group
    for(int64_t idx3 = blockIdx.x; idx3 < otherHeapSize; idx3 += gridDim.x)
    {   
        N3 = otherHeap[idx3];
        cardinality3 = convert_weights(N3, weights3);
        // Loop over otherHeap (second group)
        // Each thread handles a different second group
        for(int64_t idx2 = threadIdx.x; idx2 < otherHeapSize; idx2 += blockDim.x)
        {
            N2 = otherHeap[idx2];
            // Check for overlap between groups
            if ((N3 & N2) != 0)
            {
                continue;
            }
            
            cardinality2 = convert_weights(N2, weights2);
            // Cut the search space in half by only considering when cardinality2 <= cardinality3
            if (cardinality2 > cardinality3)
            {
                continue;
            }

            card23 = cardinality2 + cardinality3;
            // Loop over possible first groups
            for (int64_t idx1 = 0; idx1 < heapSize; ++idx1)
            {
                N1 = heap[idx1];
                cardinality1 = convert_weights(N1, weights1);
                
                // Can't do any better with the rest of the heap
                if (cardinality1 > bestCardinality)
                {
                    break;
                }

                // Group 1 needs to be the smallest
                if (cardinality1 > cardinality2)
                {
                    break;
                }

                // Group 1 needs to be the smallest
                cardinality4 = LENGTH - (cardinality1 + card23);
                if (cardinality1 > cardinality4)
                {
                    break;
                }

                // Test against the best arrangement so far
                qe1 = product(weights1);
                if (cardinality1 == bestCardinality && qe1 >= bestQE)
                {
                    break;
                }
                else
                {
                    atomicMin(&bestCardinality, cardinality1);
                    atomicMin(&bestQE, qe1);
                    break;
                }
            }
        }
    }
}

// Find the solution to Part 1
void solution1()
{
    heapSize = 0;
    heapIdx = 0;
    bestCardinality = UINT_MAX;
    bestQE = UINT64_MAX;

    // Largest than first group can be
    uint8_t worstCardinality = LENGTH / 3;

    // Step 1: Find number of possible first groups
    find_first_groups<<<BLOCKS,THREADS>>>(worstCardinality, GROUP_WEIGHT1, false);
    cudaDeviceSynchronize();

    // Step 2: Allocate heap
    allocate_heap(1);
    cudaDeviceSynchronize();

    // Step 3: Add possible first groups to heap
    find_first_groups<<<BLOCKS,THREADS>>>(worstCardinality, GROUP_WEIGHT1, true);
    cudaDeviceSynchronize();

    // Step 4: Sort first groups by cardinality, then by product
    sort_heap();
    cudaDeviceSynchronize();

    // Step 5: Find and test the valid arrangements for best cardinality and product
    test_valid_arrangements<<<BLOCKS,THREADS>>>();
    cudaDeviceSynchronize();

    std::cout << "Solution 1: " << bestQE << std::endl;
    cudaFree(heap);
}

// Find the solution to Part 2
void solution2()
{
    heapSize = 0;
    heapIdx = 0;
    bestCardinality = UINT_MAX;
    bestQE = UINT64_MAX;

    // Largest than first group can be
    uint8_t worstCardinality = LENGTH / 4;

    // Step 1: Find number of possible first groups
    find_first_groups<<<BLOCKS,THREADS>>>(worstCardinality, GROUP_WEIGHT2, false);
    cudaDeviceSynchronize();

    // Step 2: Allocate heap
    allocate_heap(1);
    cudaDeviceSynchronize();

    // Step 3: Add possible first groups to heap
    find_first_groups<<<BLOCKS,THREADS>>>(worstCardinality, GROUP_WEIGHT2, true);
    cudaDeviceSynchronize();
    
    // Step 4: Sort first heap
    sort_heap();
    cudaDeviceSynchronize();

    // Step 5: Find number of possible second groups
    find_other_groups<<<BLOCKS,THREADS>>>(false);
    cudaDeviceSynchronize();

    // Step 6: Allocate otherHeap
    allocate_heap(2);
    cudaDeviceSynchronize();
    
    // Step 7: Add possible second groups to otherHeap
    find_other_groups<<<BLOCKS,THREADS>>>(true);
    cudaDeviceSynchronize();

    // Step 8: Test valid arrangements
    test_valid_arrangements2<<<BLOCKS,THREADS>>>();
    cudaDeviceSynchronize();

    std::cout << "Solution 2: " << bestQE << std::endl;
    cudaFree(heap);
    cudaFree(otherHeap);
}

int main()
{
    solution1();
    solution2();
}